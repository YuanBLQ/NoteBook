# 缓存相关

## 常见问题

围绕缓存，最常见的三个问题：

- 缓存雪崩
- 缓存穿透
- 缓存击穿

这三个名词说出来很容易，但是要讲清楚就没那么简单了。

### 缓存雪崩

简单一句话：某一时间点，大量缓存失效，导致数据库请求激增，把数据库爆掉。

解决方案：

- 缓存失效时间加上一个随机值
- redis集群部署，将热点数据分布在不同redis库

### 缓存击穿

和上面的缓存雪崩很类似，不同的是，雪崩是大面积缓存失效，而击穿则是某一个热点 key 在高并发场景下突然失效，导致数据库被无情捶打。

解决方案：

- 加个互斥锁，缓存失效的时候只能有一个请求去请求数据库数据

### 缓存穿透

某个请求去查一个不存在的数据时，缓存不知道就自然走到了数据库，但是数据库也查不到，最终也没有任何数据写回缓存。

这就有意思了，如果这种查询操作大规模进来都会实打实的穿透缓存直击数据库。

解决方案：

- 数据查不到的时候写一个空值给缓存（当然要加个过期时间）
- 前置布隆过滤器，没有的直接返回

## 更新策略

在系统中，一旦引入缓存就会带来缓存和数据库数据不一致的风险。为了减少不一致情况的发生，常用的缓存更新策略有：

- cache aside
- read/write through
- write behind caching

### cache aside

`cache aside` AKA `旁路缓存`，是比较常用的缓存策略，数据主要是以数据库为准。

**读请求**流程

![](https://pages.isyuan.site/cache/20210315220940.png)

读的时候，会先去缓存中查看是否有对应数据，命中直接返回，否则穿透到数据库查询，查到之后写入缓存，最后返回。

**写请求**流程

![](https://pages.isyuan.site/cache/20210315220953.png)

写策略很简单，先更新数据库，然后把对应缓存删掉。

为什么是删缓存，而不直接更新缓存呢，我们接着往下看。

#### cache aside 坑

##### 坑一：先更新数据库，再更新缓存

假设同一时刻有两个`写请求`要更新数据，如果采取先更新数据库然后更新缓存这个策略，那么可能会出现下面这个情况：

![](https://pages.isyuan.site/cache/20210315221004.png)

明明一开始的时候是 `写请求1` 先到达数据库，然后 `写请求2` 才到的数据库，照理说最后 `age` 的值为 `20`，但是更新缓存的时候 `写请求2` 先更新成功，这时候缓存中 `age` 的值是 `18`。数据不一致就出现了！

##### 坑二：先删除缓存，再更新数据库

在 `读` & `写` 并发的场景下会出现下面这种情况：

![](https://pages.isyuan.site/cache/20210315221019.png)

如上图，执行流程：

1. `写请求` 删除缓存数据
2. `读请求` 去缓存查询未果，穿透到数据库，并将查询到的数据写入缓存
3. `写请求` 更新数据库

实际 `age` 的值应为 `写请求` 中的 `20` ，但却变成老数据 `18`，产生了数据不一致！

##### 坑三：先更新数据库，在删除缓存

**先更新再删除**不是说没有问题，只是理论上这种情况造成的数据不一致概率会小的多，如下面情形：

![](https://pages.isyuan.site/cache/20210315221030.png)

执行流程如下：

1. `读请求` 查询缓存未果，穿透到数据
2. `写请求` 更新数据库，然后删除缓存
3. `读请求` 将查询到的数据写入缓存

上述情况虽说会出现数据不一致，但是要想出现这种情况，就必须 `读请求` 先于 `写请求`，但是 `读请求` 从数据读取并返回写入缓存之前 `写请求` 却要先写入数据库，然后完成删除缓存操作。

上面这种情况发生的概率很小，一般加个缓存过期时间还是可以容忍的。

### read through / write through

不像上面客户端既要和缓存打交道又要和数据库打交道，一不小心还搞出个数据不一致问题。这种模式下，客户端只需和**缓存系统**打交道，然后数据库那边只需让缓存自己去管理就好了。

**read through**

从缓存中读，缓存没有由缓存组件自己去数据库加载。

**write through**

和上面一样，写数据的时候我们只管更新到缓存中，然后由缓存负责把数据更新到数据库。

### wirte back（write behind）

















