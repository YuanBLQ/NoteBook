# 接口变慢排查

接口变慢主要原因：

- 慢SQL
- 网络波动
- 服务器性能达到瓶颈
  - 磁盘IO瓶颈
  - CPU性能瓶颈
  - 网卡瓶颈

## CPU性能瓶颈

`top` 命令可以看到服务器有多少个 CPU，以及 CPU 过去 1 分钟、5 分钟、15 分钟的平均负载，各个 CPU 的使用率等信息。

### CPU 负载和使用率的区别

#### 负载的计算公式

> load = (D + R) / SUM(ALL)

一台 Linux 服务器运行时的进程按照状态主要分为 7 类：

- D（task_uninterruptible）：不可中断的睡眠状态。处于睡眠状态，但是不可以被中断。一般由 IO 等待引起的（磁盘 IO、网络 IO、外设 IO 等），出现非常短暂，一般无法使用 ps 或者 top 等工具捕获，**sleep 状态下的进程不会占用 CPU 资源。**
- R（task_running）：可执行状态。这种状态的进程处于 CPU 的可执行队列中，正在运行或者等待 CPU 运行。
- S（task_interruptible）：可中断的睡眠状态。与上面的 D 不同，该状态下的进程一般在等待某种事件的发生，例如：socket 连接、信号量等。一旦这些事件完成，进程就会被唤醒，如果不是在高负载时期，大部分进程都处于 S 状态，**不占用 CPU 资源。**
- T（task_stopped）：暂停状态，进程处于停止运行状态。
- t（task_traced）：跟踪状态。
- Z（exit_zombie）：僵死态。僵死进程，这种进程其实已经结束运行了，但还没被父进程回收资源（比如进程的描述符、PID等），僵死进程会释放掉除了进程入口之外的所有资源。
- X（exit_dead）：死亡态。

因此 **D + R** 表示的是机器的整体负载，即 CPU负载（正在运行的进程）+ Disk 负载 + 网络负载 + 其他外设负载，当出现负载高是，那么问题可能不仅仅出现在 R 态的进程，还可能是磁盘和网络 IO 引起的。

#### CPU 的使用率

cpu 是分时间片运行的，每个时间片会分配给一个进程（或线程）。

> CPU 的使用率 = CPU 执行非系统空闲进程额时间 / CPU 总的执行时间

CPU 总的执行时间主要分为四大类：

- 用户进程使用时间（User Time）
  - us（user time）：用户态进程占用的 CPU 时间
  - ni（nice time）：改变过优先级的用户态进程占用的 CPU 时间
- 系统内核使用时间（System Time）
  - sys（system time）：系统内核进程占用的 CPU 时间
  - si（soft irq time）：软中断占用的 CPU 时间
  - hi（hard irq time）：硬中断占用的 CPU 时间
- 被抢占的时间（Steal Time）
  - st（steal time）发生抢占，被强制中断发生的等待时间
- 空闲时间（Idle Time）
  - id（idle time）：除磁盘 IO 等待时间以外的其他等待时间
  - wa（waiting time）：等待磁盘 IO 的时间

### 情形分析

#### 负载高 & 使用率高

主要三类：

- sys 高。 这时候需要进一步查看上下文的切换（可以通过 vmstat 命令）
  - 如果是非自愿上下文切换，这种情况可能是由于 CPU 资源抢占比较激烈。时间片有限，不可能无限制占着，系统会强制调度，进而发生上下文的切换。
  - 如果是自愿上下文切换，这种情况可能存在大量 IO 操作或者内存等系统资源存在瓶颈，大量进程无法获取到系统资源，导致上下文切换。可以使用 iostat 查看 IO 情况或者 free 查看内存情况。
- si 高。需要进一步看软中断的类型。中断相关的信息存储在 /proc/softirqs（软中断）、/proc/interrupts（硬中断），可以通过 cat 命令查看。si 高通常是网络 IO 或者线程调度引起的，其中软中断又可以分为两大类：
  - NET_TX 和 NET_RX。NET_TX 指的是发送网络包的软中断，NET_RX 指接收网络包的软中断，显然要是这两个高那就是系统的网络 IO 存在瓶颈的可能性比较大
  - SCHED 进程调度或者负载均衡引起的中断，这种中断出现的多时，通常伴随进程的上下文切换，一般与非自愿上下文切换一起出现，可能存在 CPU 瓶颈
- us 高。用户进程占用 CPU 高，可能出现的问题是：
  - 代码出现死循环（top 和 jstack 定位具体线程的堆栈）
  - CPU 密集计算型程序
  - 内存问题，出阿信 Full GC（jstat -util pid）
  - 资源等待造成线程池满，引发 CPU 使用率飙高

如果是代码死循环问题，这种问题比较简单，通常的定位手段为：先使用 top 查询出占用 CPU 使用率最高的进程 ID(pid)，然后使用 **「top -H -p pid」** 命令查询出 pid 这个进程中占用 CPU 资源最高的线程 id，此时查询出来的线程 id 为十进制，还需要将十进制的线程 id 转换为 16 进制，可以使用如下命令：**「printf "0x%x" 线程 id」**。

