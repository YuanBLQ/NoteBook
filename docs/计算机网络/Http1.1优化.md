# Http/1.1 优化

最方便的就是使用 KeepAlive 将短连接改成长连接。

这是从底层的传输层方向入手，通过减少 TCP 连接建立和断开的次数，来减少网络传输的延迟，从而提高传输效率。

## 短连接和长连接的区别

pass

## HTTP/1.1 设计方面支持的优化

- 尽量避免发送 HTTP 请求
- 在需要发送 HTTP 请求时，考虑如何减少请求次数
- 减少服务器的 HTTP 响应的数据大小

### 如何避免发送 HTTP 请求

对于一些重复性的 HTTP 请求，比如每次请求到的数据都是一样的，就可以把这对「请求 - 响应」的数据**缓存在本地，**下次直接读取本地数据就好了。

HTTP 设计者早早的考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

具体是怎么做的呢？

客户端把第一次请求以及响应的数据保存在本地磁盘上，将请求的 URL 作为 key 响应作为 value。

后续发起相同的请求时，直接通过 key 本地查询即可。

但缓存不可能一直是最新的数据，那怎么办呢？

所以在发送 HTTP 响应的时候会估算一个过期时间，并把这个信息放在响应头部中，这样客户端如果发现缓存是过期的那就会重新发起请求。

当再次发起请求时，客户端会从第一次请求到的响应头中取出已过期的缓存摘要 Etag 头部，放在这次请求的 Etag 头部发给服务器，服务器会跟本地的数据摘要作对比，如果没过期就会返回 **304 Not Modified，**响应体是空的，这样就能提高传输效率。

### 如何减少 HTTP 请求次数

可以从这 3 个方面入手：

- 减少重定向次数
- 合并请求
- 延迟发送

#### 减少重定向次数

一个资源可能由于迁移、维护等原因从 url1 转到了 url2，而客户端不知情，当客户端请求 url1 的时候服务器不能粗暴的返回错误，而是通过 **302** 响应码和 **Location** 头部告诉客户端资源已经迁移到 url2 了，于是客户端又要向 url2 发送请求获取资源。

如果重定向次数很多，客户端就要发送和多次 HTTP 请求，如果客户端处在公网中，网络传输成本极高，降低了网络性能。

我们可以让代理服务器执行重定向，减少客户端与代理服务器之间的通讯次数，更进一步，直接把重定向信息缓存到客户端，这样下次客户端直接请求 url2，中间不需要再有中转操作。RFC 规范定义了 5 个重定向响应码，其中客户端收到 **301** 和 **308** 后都可以将重定向缓存到本地，之后客户端直接用 url2 代替 url1 请求资源。

| 状态码 | 描述               | 意义                                             |
| ------ | ------------------ | ------------------------------------------------ |
| 301    | Moved Permanently  | 资源永久重定向到另一个 url                       |
| 302    | Found              | 资源临时重定向到另一个 url                       |
| 303    | See Other          | 重定向到其他资源，常用于 POST/PUT 等方法的响应中 |
| 307    | Temporary Redirect | 类似302，但是请求方法不得改变                    |
| 308    | Permanent Redirect | 类似301，但是请求方法不得改变                    |

#### 合并请求

将一些小图片通过 CSS Image Sprites 技术合成一张大图片。

服务器端用 webpack 等打包工具将 js、css 等资源合并成大文件。

将多媒体用 base64 编码后嵌入到 HTML 中。

#### 延迟发送

最后我们还可以通过懒加载方式尽可能延迟发送请求。

### 如何减少 HTTP 响应的数据大小

对响应的资源进行 **压缩，**这样就可以减少响应的数据大小。