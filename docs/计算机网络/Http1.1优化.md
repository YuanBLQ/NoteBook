# Http/1.1 优化

最方便的就是使用 KeepAlive 将短连接改成长连接。

这是从底层的传输层方向入手，通过减少 TCP 连接建立和断开的次数，来减少网络传输的延迟，从而提高传输效率。

## HTTP/1.1 设计方面支持的优化

- 尽量避免发送 HTTP 请求
- 在需要发送 HTTP 请求时，考虑如何减少请求次数
- 减少服务器的 HTTP 响应的数据大小

### 如何避免发送 HTTP 请求

对于一些重复性的 HTTP 请求，比如每次请求到的数据都是一样的，就可以把这对「请求 - 响应」的数据**缓存在本地，**下次直接读取本地数据就好了。

HTTP 设计者早早的考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

具体是怎么做的呢？

客户端把第一次请求以及响应的数据保存在本地磁盘上，将请求的 URL 作为 key 响应作为 value。

后续发起相同的请求时，直接通过 key 本地查询即可。



![](https://pages.isyuan.site/hnet/%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE.png)

但缓存不可能一直是最新的数据，那怎么办呢？

所以在发送 HTTP 响应的时候会估算一个过期时间，并把这个信息放在响应头部中，这样客户端如果发现缓存是过期的那就会重新发起请求。

当再次发起请求时，客户端会从第一次请求到的响应头中取出已过期的缓存摘要 Etag 头部，放在这次请求的 Etag 头部发给服务器，服务器会跟本地的数据摘要作对比，如果没过期就会返回 **304 Not Modified，**响应体是空的，这样就能提高传输效率。

![](https://pages.isyuan.site/hnet/304%E5%A4%B4.png)

### 如何减少 HTTP 请求次数

可以从这 3 个方面入手：

- 减少重定向次数
- 合并请求
- 延迟发送

#### 减少重定向次数

一个资源可能由于迁移、维护等原因从 url1 转到了 url2，而客户端不知情，当客户端请求 url1 的时候服务器不能粗暴的返回错误，而是通过 **302** 响应码和 **Location** 头部告诉客户端资源已经迁移到 url2 了，于是客户端又要向 url2 发送请求获取资源。

![](https://pages.isyuan.site/hnet/302source.jpg)

如果重定向次数很多，客户端就要发送和多次 HTTP 请求，如果客户端处在公网中，网络传输成本极高，降低了网络性能。

我们可以让代理服务器执行重定向，减少客户端与代理服务器之间的通讯次数。

![](https://pages.isyuan.site/hnet/302source2.png)

更进一步，直接把重定向信息缓存到客户端，这样下次客户端直接请求 url2，中间不需要再有中转操作。

![](https://pages.isyuan.site/hnet/302source3.png)

RFC 规范定义了 5 个重定向响应码，其中客户端收到 **301** 和 **308** 后都可以将重定向缓存到本地，之后客户端直接用 url2 代替 url1 请求资源。

| 状态码 | 描述               | 意义                                             |
| ------ | ------------------ | ------------------------------------------------ |
| 301    | Moved Permanently  | 资源永久重定向到另一个 url                       |
| 302    | Found              | 资源临时重定向到另一个 url                       |
| 303    | See Other          | 重定向到其他资源，常用于 POST/PUT 等方法的响应中 |
| 307    | Temporary Redirect | 类似302，但是请求方法不得改变                    |
| 308    | Permanent Redirect | 类似301，但是请求方法不得改变                    |

#### 合并请求

将一些小图片通过 CSS Image Sprites 技术合成一张大图片。

服务器端用 webpack 等打包工具将 js、css 等资源合并成大文件。

将多媒体用 base64 编码后嵌入到 HTML 中，这样客户端接收到 HTML 之后无需再次发起请求获取资源，直接通过解码就能拿到图片数据，也就减少了请求的次数。

可见通过把多个小资源的请求合并成一个请求大资源的请求能降低请求的个数，但是也会相应的带来一些问题：如果某个小资源发生了变更，那客户端必须重新请求整个大资源才能更新，显然会造成额外的网络消耗。

#### 延迟发送

最后我们还可以通过懒加载方式尽可能延迟发送请求。

请求网页的时候没必要把所有资源都获取到，当用户下拉或者翻页的操作的时候再去服务器获取对应资源。

### 如何减少 HTTP 响应的数据大小

对响应的资源进行 **压缩，**这样就可以减少响应的数据大小。常用的压缩方式，分无损压缩和有损压缩。

gzip 就是比较常见的无损压缩。

谷歌出品的有 Brotli 算法压缩，压缩效率比 gzip 高，如果有的选还是尽可能选择 br 压缩。

另外对于图片，谷歌推出的 WebP 格式比常见的 Png 格式在相同的图片质量下，提及来的小。

### 总结

上面主要思路都是围绕 HTTP/1.1 协议做的优化，但是受限于 HTTP/1.1 协议，有些优化无法实施，后面出现的 HTTP/2 和 HTTP/3 协议则从根本上优化了网络请求。

比如 HTTP/2 的头部压缩、二进制帧、并发传输等，HTTP/3 采用 UDP 协议作为传输层协议，解决了队头阻塞问题等。